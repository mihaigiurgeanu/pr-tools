#!/usr/bin/env python3

import argparse
import difflib
import git
import glob
import os
import subprocess
import sys
import uuid
import yaml

REVIEW_DIR = '.pr-reviews'
BASE_BRANCH = 'main'

def get_review_file(branch, reviewer):
    os.makedirs(REVIEW_DIR, exist_ok=True)
    return os.path.join(REVIEW_DIR, f'{branch}-{reviewer}.yaml')

def load_state(review_file):
    if os.path.exists(review_file):
        with open(review_file, 'r') as f:
            return yaml.safe_load(f)
    return None

def save_state(review_file, state):
    with open(review_file, 'w') as f:
        yaml.safe_dump(state, f)

def generate_conflict_content(base_lines, feature_lines):
    sm = difflib.SequenceMatcher(None, base_lines, feature_lines)
    conflict_lines = []
    for op, i1, i2, j1, j2 in sm.get_opcodes():
        if op == 'equal':
            conflict_lines.extend(base_lines[i1:i2])
        else:
            conflict_lines.append('<<<<<<< BASE')
            if op in ('replace', 'delete'):
                conflict_lines.extend(base_lines[i1:i2])
            conflict_lines.append('=======')
            if op in ('replace', 'insert'):
                conflict_lines.extend(feature_lines[j1:j2])
            conflict_lines.append('>>>>>>> FEATURE')
    return conflict_lines

def extract_edited_feature(edited_lines):
    feature = []
    in_base = False
    in_feature = False
    for line in edited_lines:
        if line.startswith('<<<<<<< BASE'):
            in_base = True
            in_feature = False
            continue
        elif line.startswith('======='):
            in_base = False
            in_feature = True
            continue
        elif line.startswith('>>>>>>> FEATURE'):
            in_base = False
            in_feature = False
            continue
        if in_feature or (not in_base and not in_feature):
            feature.append(line)
    return feature

def extract_comments(original_lines, edited_lines):
    d = difflib.Differ()
    diff = list(d.compare(original_lines, edited_lines))
    comments = []
    current_add = []
    a_line = 1
    for line in diff:
        code = line[:2]
        if code == '  ':
            if current_add:
                line_num = a_line - 1
                if line_num == 0:
                    line_num = 1
                comments.append({'line': line_num, 'text': '\n'.join(current_add)})
                current_add = []
            a_line += 1
        elif code == '+ ':
            current_add.append(line[2:])
        elif code == '- ':
            print('Warning: line removed during review')
            a_line += 1
    if current_add:
        line_num = a_line
        comments.append({'line': line_num, 'text': '\n'.join(current_add)})
    return comments

def open_editor(file_path, branch, repo):
    base_content = repo.git.show(f'{BASE_BRANCH}:{file_path}')
    feature_content = repo.git.show(f'{branch}:{file_path}')
    base_lines = base_content.splitlines()
    feature_lines = feature_content.splitlines()
    conflict_lines = generate_conflict_content(base_lines, feature_lines)
    conflict_content = '\n'.join(conflict_lines) + '\n'
    import tempfile
    with tempfile.NamedTemporaryFile(mode='w', delete=False) as tmp:
        tmp.write(conflict_content)
        tmp_path = tmp.name
    editor = os.environ.get('EDITOR', 'vim')
    subprocess.call([editor, tmp_path])
    with open(tmp_path, 'r') as f:
        edited_content = f.read()
    os.unlink(tmp_path)
    edited_lines = edited_content.splitlines()
    edited_feature = extract_edited_feature(edited_lines)
    comments = extract_comments(feature_lines, edited_feature)
    return comments

def main():
    parser = argparse.ArgumentParser(description='PR Review Tool')
    subparsers = parser.add_subparsers(dest='command', required=True)

    subparsers.add_parser('start')
    subparsers.add_parser('next')
    subparsers.add_parser('previous')
    subparsers.add_parser('open')
    subparsers.add_parser('files')
    subparsers.add_parser('changes')
    comment_parser = subparsers.add_parser('comment')
    comment_parser.add_argument('--file', required=True)
    comment_parser.add_argument('--line', type=int, required=True)
    comment_parser.add_argument('--text', required=True)
    resolve_parser = subparsers.add_parser('resolve')
    resolve_parser.add_argument('--id', required=True)
    subparsers.add_parser('end')
    subparsers.add_parser('list')

    args = parser.parse_args()
    repo = git.Repo('.')
    branch = repo.active_branch.name
    reviewer = repo.config_reader().get_value('user', 'name')
    review_file = get_review_file(branch, reviewer)

    if args.command == 'start':
        files = repo.git.diff(BASE_BRANCH, name_only=True).splitlines()
        state = {'status': 'active', 'current_index': 0, 'files': files, 'comments': [], 'branch': branch, 'reviewer': reviewer}
        if os.path.exists(review_file):
            print('Review already started, resuming')
        save_state(review_file, state)

    elif args.command in ('next', 'previous', 'open'):
        state = load_state(review_file)
        if not state or state['status'] != 'active':
            print('No active review')
            sys.exit(1)
        index = state['current_index']
        if args.command == 'next':
            if index < len(state['files']) - 1:
                state['current_index'] += 1
            else:
                print('No more files')
                return
        elif args.command == 'previous':
            if index > 0:
                state['current_index'] -= 1
            else:
                print('No previous files')
                return
        save_state(review_file, state)
        file_path = state['files'][state['current_index']]
        new_comments = open_editor(file_path, branch, repo)
        state['comments'].extend([{'id': uuid.uuid4().hex[:8], 'file': file_path, 'line': c['line'], 'text': c['text'], 'resolved': False} for c in new_comments if c['text'].strip()])
        save_state(review_file, state)

    elif args.command == 'files':
        print('\n'.join(repo.git.diff(BASE_BRANCH, name_only=True).splitlines()))

    elif args.command == 'changes':
        print(repo.git.diff(BASE_BRANCH))

    elif args.command == 'comment':
        state = load_state(review_file)
        if not state or state['status'] != 'active':
            print('No active review')
            sys.exit(1)
        cmt_id = uuid.uuid4().hex[:8]
        state['comments'].append({'id': cmt_id, 'file': args.file, 'line': args.line, 'text': args.text, 'resolved': False})
        save_state(review_file, state)
        print(f'Added comment {cmt_id}')

    elif args.command == 'resolve':
        state = load_state(review_file)
        if not state:
            print('No review')
            sys.exit(1)
        for c in state['comments']:
            if c['id'] == args.id:
                c['resolved'] = True
                save_state(review_file, state)
                print(f'Resolved {args.id}')
                return
        print('Comment not found')

    elif args.command == 'end':
        state = load_state(review_file)
        if not state:
            print('No review')
            sys.exit(1)
        state['status'] = 'closed'
        save_state(review_file, state)
        print('Review ended')

    elif args.command == 'list':
        for rf in glob.glob(os.path.join(REVIEW_DIR, '*.yaml')):
            state = load_state(rf)
            if state:
                print(f'{state["branch"]} by {state["reviewer"]}: {state["status"]}')

if __name__ == '__main__':
    main()
